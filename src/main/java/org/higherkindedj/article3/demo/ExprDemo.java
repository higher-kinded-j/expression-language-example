// Copyright (c) 2025 Magnus Smith
// Licensed under the MIT License. See LICENSE.md in the project root for license information.
package org.higherkindedj.article3.demo;

import org.higherkindedj.article3.ast.*;
import org.higherkindedj.article3.ast.Expr.Binary;
import org.higherkindedj.article3.ast.Expr.Conditional;
import org.higherkindedj.article3.ast.Expr.Literal;
import org.higherkindedj.article3.ast.Expr.Variable;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.focus.AffinePath;
import org.higherkindedj.optics.focus.FocusPath;

import java.util.Optional;

/**
 * Demonstrates the Expression AST and Focus DSL from Article 3.
 *
 * <p>This demo shows:
 *
 * <ul>
 *   <li>Building expression trees using records
 *   <li>Using prisms to inspect and modify expression variants
 *   <li>Composing optics with the Focus DSL for fluent navigation
 *   <li>Pattern matching with sealed interfaces
 * </ul>
 *
 * <p>The optics used here are auto-generated by Higher-Kinded-J's {@code @GenerateLenses}, {@code
 * @GeneratePrisms}, and {@code @GenerateFocus} annotations on the AST types.
 */
public final class ExprDemo {

  public static void main(String[] args) {
    System.out.println("=== Expression AST Demo (Article 3) ===\n");

    buildingExpressions();
    usingPrisms();
    focusDslComposition();
    patternMatching();
  }

  private static void buildingExpressions() {
    System.out.println("--- Building Expressions ---\n");

    // Simple literals
    Expr intLit = new Literal(42);
    Expr boolLit = new Literal(true);
    Expr strLit = new Literal("hello");

    System.out.println("Integer literal: " + intLit.format());
    System.out.println("Boolean literal: " + boolLit.format());
    System.out.println("String literal:  " + strLit.format());

    // Variables
    Expr varX = new Variable("x");
    Expr varY = new Variable("y");

    System.out.println("Variable x: " + varX.format());
    System.out.println("Variable y: " + varY.format());

    // Binary operations: x + y * 2
    Expr two = new Literal(2);
    Expr yTimesTwo = new Binary(varY, BinaryOp.MUL, two);
    Expr xPlusYTimesTwo = new Binary(varX, BinaryOp.ADD, yTimesTwo);

    System.out.println("x + y * 2: " + xPlusYTimesTwo.format());

    // Conditional: if (x > 0) then x else -x
    Expr zero = new Literal(0);
    Expr condition = new Binary(varX, BinaryOp.GT, zero);
    Expr negX = new Binary(new Literal(0), BinaryOp.SUB, varX);
    Expr absX = new Conditional(condition, varX, negX);

    System.out.println("abs(x): " + absX.format());
    System.out.println();
  }

  private static void usingPrisms() {
    System.out.println("--- Using Prisms (generated by @GeneratePrisms) ---\n");

    // These prisms are auto-generated by higher-kinded-j
    Prism<Expr, Literal> literalPrism = ExprPrisms.literal();
    Prism<Expr, Binary> binaryPrism = ExprPrisms.binary();
    Prism<Expr, Variable> variablePrism = ExprPrisms.variable();

    Expr lit = new Literal(42);
    Expr var = new Variable("x");
    Expr bin = new Binary(new Literal(1), BinaryOp.ADD, new Literal(2));

    // matches() - check if an expression is a specific variant
    System.out.println("Is 42 a Literal? " + literalPrism.matches(lit));
    System.out.println("Is 42 a Binary? " + binaryPrism.matches(lit));
    System.out.println("Is x a Variable? " + variablePrism.matches(var));
    System.out.println("Is 1+2 a Binary? " + binaryPrism.matches(bin));

    // getOptional() - safely extract the variant
    System.out.println(
        "\nExtract Literal from 42: " + literalPrism.getOptional(lit).map(Literal::value));
    System.out.println("Extract Binary from 42: " + binaryPrism.getOptional(lit).map(Binary::op));

    // build() - construct an Expr from a variant
    Expr newLit = literalPrism.build(new Literal(100));
    System.out.println("\nBuilt from Literal: " + newLit.format());

    // modify() - transform if the variant matches
    Expr modified = literalPrism.modify(l -> new Literal(((Integer) l.value()) * 2), lit);
    System.out.println("Double literal 42: " + modified.format());

    Expr notModified = literalPrism.modify(l -> new Literal(((Integer) l.value()) * 2), var);
    System.out.println("Double variable x (no change): " + notModified.format());
    System.out.println();
  }

  private static void focusDslComposition() {
    System.out.println("--- Focus DSL Composition ---\n");

    // The Focus DSL provides fluent navigation through nested structures.
    // Each generated Focus class wraps lenses in FocusPath objects.

    // FocusPath: Binary → Expr (left operand)
    FocusPath<Binary, Expr> leftPath = BinaryFocus.left();

    Binary bin = new Binary(new Literal(1), BinaryOp.ADD, new Literal(2));

    // Get the left operand directly
    Expr left = leftPath.get(bin);
    System.out.println("Get left from 1+2: " + left.format());

    // Set a new left operand (returns new immutable Binary)
    Binary updated = leftPath.set(new Literal(99), bin);
    System.out.println("Set left to 99: " + updated.format());

    // Modify the left operand with a function
    Binary transformed = leftPath.modify(l -> new Binary(l, BinaryOp.MUL, new Literal(10)), bin);
    System.out.println("Transform left to (left * 10): " + transformed.format());

    // Compose with prisms using andThen() for optional navigation
    // Prism.andThen(Lens) yields Affine, which we wrap in AffinePath
    // AffinePath: Expr → Literal → value (may not exist if not a Literal)
    AffinePath<Expr, Object> literalValuePath =
        AffinePath.of(ExprPrisms.literal().andThen(LiteralLenses.value()));

    Expr lit = new Literal(42);
    Expr var = new Variable("x");

    System.out.println("\nGet value from Literal 42: " + literalValuePath.getOptional(lit));
    System.out.println("Get value from Variable x: " + literalValuePath.getOptional(var));

    // Modify if it's a literal, otherwise unchanged
    Expr doubled = literalValuePath.modify(v -> ((Integer) v) * 2, lit);
    System.out.println("Double literal value: " + doubled.format());

    // Deep composition: Binary → left → as Literal → value
    // Compose the prism and lens first, then use via() on the FocusPath
    AffinePath<Binary, Object> leftLiteralValue =
        BinaryFocus.left().via(ExprPrisms.literal().andThen(LiteralLenses.value()));

    Optional<Object> deepValue = leftLiteralValue.getOptional(bin);
    System.out.println("\nDeep access (1+2).left.value: " + deepValue);

    // The path handles all the type checking internally
    Binary nested = new Binary(new Variable("x"), BinaryOp.ADD, new Literal(2));
    System.out.println("Deep access (x+2).left.value: " + leftLiteralValue.getOptional(nested));
    System.out.println();
  }

  private static void patternMatching() {
    System.out.println("--- Pattern Matching with Sealed Types ---\n");

    Expr expr =
        new Conditional(
            new Binary(new Variable("x"), BinaryOp.GT, new Literal(0)),
            new Variable("x"),
            new Binary(new Literal(0), BinaryOp.SUB, new Variable("x")));

    System.out.println("Expression: " + expr.format());
    System.out.println("Description: " + describe(expr));
    System.out.println("Variable count: " + countVariables(expr));
    System.out.println("Literal count: " + countLiterals(expr));
    System.out.println();
  }

  /** Describe an expression using exhaustive pattern matching. */
  private static String describe(Expr expr) {
    return switch (expr) {
      case Literal(Object v) -> "a literal value: " + v;
      case Variable(String name) -> "a variable named: " + name;
      case Binary(var l, var op, var r) ->
          "a binary " + op.symbol() + " with " + describe(l) + " and " + describe(r);
      case Conditional(var c, var t, var e) -> "a conditional on " + describe(c);
    };
  }

  /** Count variables in an expression using recursion. */
  private static int countVariables(Expr expr) {
    return switch (expr) {
      case Literal(_) -> 0;
      case Variable(_) -> 1;
      case Binary(var l, var op, var r) -> countVariables(l) + countVariables(r);
      case Conditional(var c, var t, var e) ->
          countVariables(c) + countVariables(t) + countVariables(e);
    };
  }

  /** Count literals in an expression using recursion. */
  private static int countLiterals(Expr expr) {
    return switch (expr) {
      case Literal(_) -> 1;
      case Variable(_) -> 0;
      case Binary(var l, var op, var r) -> countLiterals(l) + countLiterals(r);
      case Conditional(var c, var t, var e) ->
          countLiterals(c) + countLiterals(t) + countLiterals(e);
    };
  }
}
